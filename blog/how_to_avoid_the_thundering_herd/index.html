<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="blog, coder, golang" name="keywords">
<meta content="Yuri Zhang" name="author">
<meta property="og:title" content="ATS零碎笔记(二) - 避免雪崩 - yuri | Lab">
<meta property="og:url" content="http://www.yurilab.com/blog/how_to_avoid_the_thundering_herd/">
<meta property="og:description" content="The Lab where I can show my mind">
<meta property="og:type" content="website" />
<title>ATS零碎笔记(二) - 避免雪崩 | yuri | Lab</title>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<link rel="stylesheet" href="http://www.yurilab.com/css/style.css">
<link rel="shortcut icon" href="http://www.yurilab.com/wave.ico">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/github.min.css">

</head>

<body>
<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="http://www.yurilab.com"><h1 class="title is-4">yuri | Lab</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/zhyuri" target="_blank">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/YuriTheCoder" target="_blank">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://www.linkedin.com/in/%E5%8F%8B%E5%8A%9B-%E5%BC%A0-390a2797/" target="_blank">
            <span class="icon">
              <i class="fa fa-linkedin-square"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml" target="_blank">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h1 class="title">ATS零碎笔记(二) - 避免雪崩</h1>
    <h2 class="subtitle is-5">March 17, 2016 by Yuri Zhang</h2>
    
    <div class="content">
      

<p>在应对高并发的请求时，ATS能够顽强的抗住请求压力，高速的输出缓存内容，但是当请求失效的时候，
ATS不得不向回源机发起请求，希望重新获得这块内容并缓存起来。那么这里就有一个问题：</p>

<blockquote>
<p>当ATS发现缓存失效，向回源机发起请求，在拿回全部内容之前，这段时间内的用户请求要怎么处理？</p>
</blockquote>

<p>如果这里我们不做任何设计和配置，最原始的方案就是放过所有请求，大家都去回源机请求一次新数据，
那么在这段真空期内，就像开闸泄洪一般，一大批请求在极短的时间内被疯狂打在回源机上，会造成一系列
附带的问题，可能会对后端相关联的服务造成巨大影响。这就是我们需要解决的&rdquo;雪崩&rdquo;。</p>

<p>那么定位了问题，解决方案很容易可以想到:</p>

<ol>
<li>在真空期内，让ATS输出旧内容，并且保证只有一个请求被放过去回源机。</li>
<li>在回源机返回新内容的过程中，ATS尽可能早的向客户端返回新的内容。</li>
</ol>

<p>这样一来，一方面可以保证回源机的安全，另一方面也可以尽可能快的恢复该页面的缓存服务。</p>

<p>为了实现这样两个目标，我们需要对ATS进行一些配置，开启相应的功能。</p>

<h2 id="open-write-fail-action">open_write_fail_action</h2>

<p><code>proxy.config.http.cache.open_write_fail_action</code>是一个很迷的配置，从字面上来看似乎很难理解
<code>open_write_fail_action</code>，其实很简单。当某个请求触发到一个已失效的Cache Obejct时，
ATS会去回源机回源，显然ATS不会允许所有请求都去回源一次，这样即浪费客户端时间也会对回源机施加不必要的压力，
因此ATS在这里针对每一个Cache Key加了一个写入锁，只有一个请求可以拿下这个锁，并触发回源机制，
其他请求发现拿不到这个锁的时候，就会采取<code>proxy.config.http.cache.open_write_fail_action</code>这里配置的行为，
有以下几种行为可以被配置，当然，这里是在<code>records.config</code>当中配置并reload：</p>

<pre><code>Scope:          CONFIG
Type:           INT
Default:        0
Reloadable:     Yes
Overridable:    Yes
</code></pre>

<ul>
<li>0 : 默认，所有请求都去回源。</li>
<li>1 : 如果缓存Miss返回502，其他情况回源。</li>
<li>2 : 如果缓存对象的生存时间小于<code>proxy.config.http.cache.max_stale_age</code>返回旧版本缓存，否则回源。</li>
<li>3 : 如果缓存Miss返回502，如果有缓存但是已过期则和配置2一致。</li>
<li>4 : 无论缓存Miss或失效都返回502。</li>
</ul>

<p>需要强调的是，以上配置被触发的条件是：</p>

<ol>
<li>缓存Miss或缓存过期。</li>
<li>同时有多个请求，除了回源的那个以外其他请求拿不到写入锁。</li>
</ol>

<p>其中action = 2的配置实际产生效果的位置是在源码中<code>proxy/http/HttpTransact.cc</code>的<code>HttpTransact::what_is_document_freshness</code>中。</p>

<h2 id="read-while-writer">Read While Writer</h2>

<p>边写边读机制在各类缓存服务器都有采用，大部分的缓存服务器会在收到回源机返回的请求后，立刻向客户端输出新数据，
也就是说从回源机开始返回Header头信息的时候，缓存服务器拿到一点就向客户端返回一点，尽可能的减少客户端排队的时间。
在ATS这里情况有些不同，ATS会等到Header头信息返回完毕之后，再向客户端开始返回内容，这样ATS可以从头信息知道
该缓存是否需要更新，如果缓存并未修改，那么ATS可以很愉快的根据Header的<code>Cache Control</code>重置旧缓存的有效期，
如果缓存有修改，那么ATS会向其他缓存服务器那样一边接收回源机内容，一边向客户端返回新内容。</p>

<p>为了开启这个功能，需要在<code>records.config</code>中进行配置：</p>

<pre><code>CONFIG proxy.config.cache.enable_read_while_writer INT 1
CONFIG proxy.config.cache.max_doc_size INT 0
CONFIG proxy.config.http.background_fill_active_timeout INT 0
CONFIG proxy.config.http.background_fill_completed_threshold FLOAT 0.000000
</code></pre>

<p><code>cache.enable_read_while_writer</code>功能开关，默认为0关闭。</p>

<p><code>cache.max_doc_size</code>单个缓存的容量上限。</p>

<p><code>http.background_fill_active_timeout</code>配置ATS Background fill回源的超时时间。这里设置为0，
也就是当某客户端请求触发回源之后，这个回源请求永远不会超时。</p>

<p><code>http.background_fill_completed_threshold</code>配置一个百分比，当客户端请求拿到回源机数据百分之多少的时候，
ATS可以介入接管writer。这里设置为百分之零，这样ATS可以立刻介入接管，不用担心触发回源的客户端请求断开。</p>

<p>这样还没有结束，还有两个配置</p>

<pre><code>CONFIG proxy.config.cache.read_while_writer.max_retries INT 10
CONFIG proxy.config.cache.read_while_writer_retry.delay INT 50
</code></pre>

<p><code>read_while_writer.max_retries</code>设置了ATS尝试获取写入锁的最大重试次数。
<code>read_while_writer_retry.delay</code>设置了尝试获取写入锁的间隔时间，需要注意的是ATS采取一种步进的方式，
下一次的间隔时间是本次时间的两倍。</p>

<h2 id="模糊回源">模糊回源</h2>

<p>ATS可以根据给定的概率在一个缓存失效之前尝试回源。这样虽然大家失效时间一模一样，也会有不同的回源时机。
同样在<code>records.config</code>中配置</p>

<pre><code>CONFIG proxy.config.http.cache.fuzz.time INT 240
CONFIG proxy.config.http.cache.fuzz.probability FLOAT 0.005
CONFIG proxy.config.http.cache.fuzz.min_time INT 0
</code></pre>

<p>对于一个在某缓存失效前的<code>fuzz.time</code>秒内的请求，它有<code>fuzz.probability</code> * 100% 的概率触发一次回源，
对于生存时间小于<code>fuzz.time</code>的缓存，会根据<code>fuzz.min_time</code>的配置，在该时间开始随机触发回源。</p>

<p><strong>需要注意的是：当回源动作触发之后，这个缓存会被认定为失效，之后的请求都会触发缓存失效逻辑，
结合文章开始时提到的<code>open_write_fail_action</code>，即可悄无声息的提前回源掉这个缓存。</strong></p>

<p>这个配置也可以在<code>remap.config</code>或通过插件覆盖，这样可以针对不同的请求单独调整。</p>

<p>对于生存时间很短的缓存来说，务必要开启<code>fuzz.min_time</code>，这样在命中概率后，会在 <code>fuzz.min_time</code> 与 <code>fuzz.time</code>
之间用一个类似指数的函数计算出一个合适的回源时机。这里需要注意看源码<code>proxy/http/HttpTransact.cc</code>中的<code>HttpTransact::calculate_freshness_fuzz</code>函数，
会先根据概率判断是否命中，再根据是否设定了<code>fuzz.min_time</code>采取不同的计算公式。</p>

<h2 id="读重试-超时">读重试&amp;超时</h2>

<p>这个功能主要为了降低某一缓存的并发回源请求数，当某一缓存正在回源过程中，其他同样的请求将会根据配置
间隔<code>proxy.config.http.cache.open_read_retry_time</code>毫秒重试<code>proxy.config.http.cache.max_open_read_retries</code>次。</p>

<h3 id="推荐阅读">[推荐阅读]</h3>

<p><strong><a href="https://docs.trafficserver.apache.org/en/latest/admin-guide/files/records.config.en.html#proxy-config-http-cache-open-write-fail-action">Reducing Origin Server Requests (Avoiding the Thundering Herd)</a></strong></p>

<p><strong><a href="https://docs.trafficserver.apache.org/en/latest/admin-guide/files/records.config.en.html#proxy-config-http-background-fill-active-timeout">proxy.config.http.background_fill_active_timeout</a></strong></p>

<p><strong><a href="https://docs.trafficserver.apache.org/en/latest/admin-guide/files/records.config.en.html#proxy-config-http-cache-fuzz-min-time">proxy.config.http.cache.fuzz.min_time</a></strong></p>

    </div>
    
        <div class="nav-left">
    <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.yurilab.com%2fblog%2fhow_to_avoid_the_thundering_herd%2f" title="Share on Facebook" target="_blank"><span class="fa fa-facebook fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://plus.google.com/share?url=http%3a%2f%2fwww.yurilab.com%2fblog%2fhow_to_avoid_the_thundering_herd%2f" title="Share on Google+" target="_blank"><span class="fa fa-google-plus fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fwww.yurilab.com%2fblog%2fhow_to_avoid_the_thundering_herd%2f" title="Share on LinkedIn" target="_blank"><span class="fa fa-linkedin fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://twitter.com/home?status=ATS%e9%9b%b6%e7%a2%8e%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20-%20%e9%81%bf%e5%85%8d%e9%9b%aa%e5%b4%a9 - http%3a%2f%2fwww.yurilab.com%2fblog%2fhow_to_avoid_the_thundering_herd%2f" title="Tweet this" target="_blank"><span class="fa fa-twitter fa-2x"></span></a>
    <a class="nav-item" href="http://www.reddit.com/submit?url=http%3a%2f%2fwww.yurilab.com%2fblog%2fhow_to_avoid_the_thundering_herd%2f&title=ATS%e9%9b%b6%e7%a2%8e%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20-%20%e9%81%bf%e5%85%8d%e9%9b%aa%e5%b4%a9" title="Share on Reddit" target="_blank"><span class="fa fa-reddit-alien fa-2x" aria-hidden="true"></span></a>
    
    </div>
    
  </div>
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'yurilab';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p>&copy; 2017 | Follow on <a href="https://twitter.com/YuriTheCoder" target="_blank">Twitter</a> | using <a href="https://github.com/mgjohansen/hucore.git" target="_blank">Hucore theme</a> & <a href="http://gohugo.io" target="_blank">Hugo</a> ♥</p>
  </div>
</section>


<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js" integrity="sha256-+bhVTaRmJ/c07eV80nU8gD2cBBF0rYkf1txqXlrbvb0=" crossorigin="anonymous"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/go.min.js"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/languages/dockerfile.min.js"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-101624162-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>



</body>
